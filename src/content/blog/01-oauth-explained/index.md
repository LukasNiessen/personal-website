---
title: "ELI5: How does OAuth work?"
summary: "OAuth explained. Super short summary, a detailed summary and a code snippet."
date: "Mar 01 2025"
draft: false
repoUrl: "https://github.com/LukasNiessen/oauth-explained"
xLink: "https://x.com/iamlukasniessen/status/1916198973292810551"
linkedInLink: "https://www.linkedin.com/pulse/eli5-how-does-oauth-work-lukas-nie%C3%9Fen-yxmke/"
tags:
  - ELI5
  - Explained
  - OAuth
  - Authorization
  - IAM
  - Security
---

# OAuth Explained

## The Basic Idea

Let's say LinkedIn wants to let users import their Google contacts.

One obvious (but terrible) option would be to just ask users to enter their Gmail email and password directly into LinkedIn. But giving away your actual login credentials to another app is a huge security risk.

OAuth was designed to solve exactly this kind of problem.

Note: So OAuth solves an authorization problem! Not an authentication problem. See [here][ref1] for the difference. OAuth is an abbreviation for Open Authorization.

## Super Short Summary

- User clicks “Import Google Contacts” on LinkedIn
- LinkedIn redirects user to Google's OAuth consent page
- User logs in and approves access
- Google redirects back to LinkedIn with a one-time code
- LinkedIn uses that code to get an access token from Google
- LinkedIn uses the access token to call Google's API and fetch contacts

## More Detailed Summary

Suppose LinkedIn wants to import a user's contacts from their Google account.

1. LinkedIn sets up a Google API account and receives a client_id and a client_secret
   - So Google knows this client id is LinkedIn
2. A user visits LinkedIn and clicks "Import Google Contacts"
3. LinkedIn redirects the user to Google's authorization endpoint:
   https://accounts.google.com/o/oauth2/auth?client_id=12345&redirect_uri=https://linkedin.com/oauth/callback&scope=contacts

- client_id is the before mentioned client id, so Google knows it's LinkedIn
- redirect_uri is very important. It's used in step 6
- in scope LinkedIn tells Google how much it wants to have access to, in this case the contacts of the user

4. The user will have to log in at Google
5. Google displays a consent screen: "LinkedIn wants to access your Google contacts. Allow?" The user clicks "Allow"
6. Google generates a one-time authorization code and redirects to the URI we specified: redirect_uri. **It appends the one-time code as a URL parameter**.
   - So the URL could be https://linkedin.com/oauth/callback?code=one_time_code_xyz
7. Now, LinkedIn makes a server-to-server request (not a redirect) to Google's token endpoint and receive an access token (and ideally a refresh token)
8. **Finished**. Now LinkedIn can use this access token to access the user's Google contacts via Google's API

---

**Question:**
_Why not already send the access token in step 6?_

**Answer:** To make sure that the requester is actually LinkedIn. So far, all requests to Google have come from the user's browser, with only the client_id identifying LinkedIn. Since the client_id isn't secret and could be guessed by an attacker, Google can't know for sure that it's actually LinkedIn behind this.

Authorization servers (Google in this example) use predefined URIs. So LinkedIn needs to specify predefined URIs when setting up their Google API. And if the given redirect_uri is not among the predefined ones, then Google rejects the request. See here: https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2.2

Additionally, LinkedIn includes the client_secret in the server-to-server request. This, however, is mainly intended to protect against the case that somehow intercepted the one time code, so he can't use it.

## Security Note: Encryption

OAuth 2.0 does **not** handle encryption itself. It relies on HTTPS (SSL/TLS) to secure sensitive data like the client_secret and access tokens during transmission.

## Security Addendum: The state Parameter

The state parameter is critical to prevent cross-site request forgery (CSRF) attacks. It's a unique, random value generated by the third-party app (e.g., LinkedIn) and included in the authorization request. Google returns it unchanged in the callback. LinkedIn verifies the state matches the original to ensure the request came from the user, not an attacker.

For an example of how a CSRF attack would work without the state param, see [here][csrf-ref].

## OAuth 1.0 vs OAuth 2.0 Addendum:

OAuth 1.0 required clients to cryptographically sign every request, which was more secure but also much more complicated. OAuth 2.0 made things simpler by relying on HTTPS to protect data in transit, and using bearer tokens instead of signed requests.

## OIDC

If you want to use OAuth for authentication, you should use OIDC. It's a protocol that builds on top of OAuth 2.0. I wrote a very similar guide about it here: https://github.com/LukasNiessen/oidc-explained

## Code Example: OAuth 2.0 Login Implementation

Below is a standalone Node.js example using Express to handle OAuth 2.0 login with Google, storing user data in a SQLite database.

```javascript
const express = require("express");
const axios = require("axios");
const sqlite3 = require("sqlite3").verbose();
const crypto = require("crypto");
const jwt = require("jsonwebtoken");
const jwksClient = require("jwks-rsa");

const app = express();
const db = new sqlite3.Database(":memory:");

// Initialize database
db.serialize(() => {
  db.run(
    "CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, email TEXT)"
  );
  db.run(
    "CREATE TABLE federated_credentials (user_id INTEGER, provider TEXT, subject TEXT, PRIMARY KEY (provider, subject))"
  );
});

// Configuration
const CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
const CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
const REDIRECT_URI = "https://example.com/oauth2/callback";
const SCOPE = "openid profile email";

// JWKS client to fetch Google's public keys
const jwks = jwksClient({
  jwksUri: "https://www.googleapis.com/oauth2/v3/certs",
});

// Function to verify JWT
async function verifyIdToken(idToken) {
  return new Promise((resolve, reject) => {
    jwt.verify(
      idToken,
      (header, callback) => {
        jwks.getSigningKey(header.kid, (err, key) => {
          callback(null, key.getPublicKey());
        });
      },
      {
        audience: CLIENT_ID,
        issuer: "https://accounts.google.com",
      },
      (err, decoded) => {
        if (err) return reject(err);
        resolve(decoded);
      }
    );
  });
}

// Generate a random state for CSRF protection
app.get("/login", (req, res) => {
  const state = crypto.randomBytes(16).toString("hex");
  req.session.state = state; // Store state in session
  const authUrl = `https://accounts.google.com/o/oauth2/auth?client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}&scope=${SCOPE}&response_type=code&state=${state}`;
  res.redirect(authUrl);
});

// OAuth callback
app.get("/oauth2/callback", async (req, res) => {
  const { code, state } = req.query;

  // Verify state to prevent CSRF
  if (state !== req.session.state) {
    return res.status(403).send("Invalid state parameter");
  }

  try {
    // Exchange code for tokens
    const tokenResponse = await axios.post(
      "https://oauth2.googleapis.com/token",
      {
        code,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET,
        redirect_uri: REDIRECT_URI,
        grant_type: "authorization_code",
      }
    );

    const { id_token } = tokenResponse.data;

    // Verify ID token (JWT)
    const decoded = await verifyIdToken(id_token);
    const { sub: subject, name, email } = decoded;

    // Check if user exists in federated_credentials
    db.get(
      "SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?",
      ["https://accounts.google.com", subject],
      (err, cred) => {
        if (err) return res.status(500).send("Database error");

        if (!cred) {
          // New user: create account
          db.run(
            "INSERT INTO users (name, email) VALUES (?, ?)",
            [name, email],
            function (err) {
              if (err) return res.status(500).send("Database error");

              const userId = this.lastID;
              db.run(
                "INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)",
                [userId, "https://accounts.google.com", subject],
                (err) => {
                  if (err) return res.status(500).send("Database error");
                  res.send(`Logged in as ${name} (${email})`);
                }
              );
            }
          );
        } else {
          // Existing user: fetch and log in
          db.get(
            "SELECT * FROM users WHERE id = ?",
            [cred.user_id],
            (err, user) => {
              if (err || !user) return res.status(500).send("Database error");
              res.send(`Logged in as ${user.name} (${user.email})`);
            }
          );
        }
      }
    );
  } catch (error) {
    res.status(500).send("OAuth or JWT verification error");
  }
});

app.listen(3000, () => console.log("Server running on port 3000"));
```

# License

MIT

[ref1]: https://stackoverflow.com/questions/6556522/authentication-versus-authorization
[csrf-ref]: https://stackoverflow.com/questions/35985551/how-does-csrf-work-without-state-parameter-in-oauth2-0
